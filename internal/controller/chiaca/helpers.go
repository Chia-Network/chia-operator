/*
Copyright 2023 Chia Network Inc.
*/

package chiaca

import (
	"context"

	k8schianetv1 "github.com/chia-network/chia-operator/api/v1"
	"github.com/chia-network/chia-operator/internal/controller/common/consts"
	"github.com/chia-network/chia-operator/internal/controller/common/kube"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
)

// getLabels assembles labels for ChiaCA related objects
func (r *ChiaCAReconciler) getLabels(ctx context.Context, ca k8schianetv1.ChiaCA, additionalLabels ...map[string]string) map[string]string {
	var labels = make(map[string]string)
	for _, addition := range additionalLabels {
		for k, v := range addition {
			labels[k] = v
		}
	}
	labels["app.kubernetes.io/instance"] = ca.Name
	labels["app.kubernetes.io/name"] = ca.Name
	labels = kube.GetCommonLabels(ctx, labels)
	return labels
}

// getCASecret fetches the k8s Secret that matches this ChiaCA deployment. Returns Secret, boolean, and error (if any).
// Boolean will be true if there is an error and it was generated by the NewNotFound wrapped error helper.
func (r *ChiaCAReconciler) getCASecret(ctx context.Context, ca k8schianetv1.ChiaCA) (corev1.Secret, bool, error) {
	var caSecret corev1.Secret
	err := r.Get(ctx, types.NamespacedName{
		Namespace: ca.Namespace,
		Name:      ca.Spec.Secret,
	}, &caSecret)
	if err != nil && errors.IsNotFound(err) {
		return caSecret, true, nil
	}
	if err != nil {
		return caSecret, false, err
	}

	return caSecret, false, nil
}

// getOwnerReference gives the common owner reference spec for ChiaCA related objects
func (r *ChiaCAReconciler) getOwnerReference(ctx context.Context, ca k8schianetv1.ChiaCA) []metav1.OwnerReference {
	return []metav1.OwnerReference{
		{
			APIVersion: ca.APIVersion,
			Kind:       ca.Kind,
			Name:       ca.Name,
			UID:        ca.UID,
			Controller: &consts.ControllerOwner,
		},
	}
}
